
---
# 문제 1. 

### 시나리오

사용자가 웹사이트에서 얼마나 오래 머무를 지를 예측한다. 우리의 목표는 예측 값과 실제 값 사이의 차이를 최소화 하는 것이다. 
그러나 우리는 사용자가 실제로 예상한 시간보다 더 오래 머무르는 것을 선호한다. 

### 문제 이해 및 목표 설정 

- 문제 : 웹사이트에서 사용자의 체류 시간 예측 
- 목표 : 실제 체류 시간과 예측 시간의 차이를 최소화. 실제 체류 시간이 예측보다 긴 경우는 덜 중요하지만, 예측이 실제보다 짧은 경우는 더 큰 손실을 부과하는 것을 원함. 


### 수식 설계

기본적인 평균 절대 오차 (Mean Absolute Error, MAE)에 변형을 가할 수 있다. 

- $\text{MAE} = {1 \over N} \Sigma^{N}_{i=1} |{y_{i} - \hat{y}_i}|$   여기서 $y_i$ 는 실제 값, $\hat{y}_i$ 는 예측 값, 그리고 N은 샘플의 수 

우리는 예측이 실제보다 짧을 경우 더 큰 패널티를 주고 싶으므로, 손실 함수에 가중치를 도입할 수 있다. 예를 들어 다음과 같이 조정할 수 있다. 

- $\text{Custom Loss} = {1 \over N} \Sigma^{N}_{i=1} w_i|{y_{i} - \hat{y}_i}|$
여기서 $w_i$ 는 가중치로, 예측이 실제보다 짧은 경우 ($y_i > \hat{y}_i$) 에는 $w_i$ 를 더 크게 설정하고, 그렇지 않은 경우 ($y_i \leq \hat{y}_i$) 에는 $w_i$ 를 1로 설정할 수 있다. 
예를 들어 $w_i = 2$ (예측이 실제보다 짧은 경우) 와  $w_i = 1$ (그렇지 않은경우) 로 설정할 수 있다. 

### 손실 함수의 구현 및 사용 
``` python
def custom_loss(y_true, y_pred):
	# 예측이 실제보다 짧은 경우 가중치를 더 크게 설정 
	w = tf.where(y_true > y_pred, 2.0, 1.0)
	return tf.reduce_mean(w * tf.abs(y_true - y_pred))

model.compile(optimizer = 'adam', loss = custom_loss)
```




---
# 문제 2.
### 손실 함수 설계: 가중 크로스 엔트로피


### 시나리오: 의료 진단 모델 개발

#### 문제 상황
당신은 의료 데이터 과학자로서, 특정 질병을 진단하기 위한 머신러닝 모델을 개발하고 있습니다. 이 모델은 환자의 다양한 생체 신호와 임상 정보를 바탕으로 해당 질병의 존재 여부를 예측합니다. 이 경우, False Negative(실제로는 질병이 있지만, 모델이 질병이 없다고 예측)의 결과는 매우 심각한 건강 문제로 이어질 수 있으므로, 이를 최대한 피하는 것이 중요합니다. 반면, False Positive(실제로는 질병이 없지만, 모델이 질병이 있다고 예측)는 추가 검사를 필요로 하는 불편함과 비용을 발생시킵니다.

#### 목표
모델이 False Negative를 최대한 줄이면서도, 전반적인 예측 정확도를 유지하도록 손실 함수를 설계하려고 합니다.

### 손실 함수 설계: 가중 크로스 엔트로피

#### 공식
$\text{Weighted Cross-Entropy Loss} = -\frac{1}{N} \sum_{i=1}^{N} \left[ \beta y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right]$

여기서:
- $N$은 샘플의 수입니다.
- $y_i$는 실제 레이블 (0 또는 1)입니다.
- $\hat{y}_i$는 모델의 예측 확률입니다.
- $\beta$는 True Positive에 더 큰 가중치를 주기 위한 가중치이며, False Negative의 비용을 반영합니다. 일반적으로 $\beta > 1$ 로 설정합니다.

#### 공식 해설
가중 크로스 엔트로피 손실 함수는 질병이 있는 경우의 예측에 더 큰 가중치를 두어, 모델이 질병이 있는 환자를 놓치는 경우의 손실을 크게 만듭니다. 이로써 모델이 False Negative를 줄이도록 유도하며, 질병의 조기 진단에 있어 더 민감하게 반응하도록 합니다.

### 코드 구현 (TensorFlow 예시)

```python
import tensorflow as tf

def weighted_cross_entropy(beta):
    def loss(y_true, y_pred):
        # 크로스 엔트로피 계산
        loss = -beta * y_true * tf.math.log(y_pred) - (1 - y_true) * tf.math.log(1 - y_pred)
        return tf.reduce_mean(loss)
    return loss

# 모델 컴파일 시 사용
beta_value = 2.0  # 예시 가중치. False Negative의 비용이 높다고 가정
model.compile(optimizer='adam', loss=weighted_cross_entropy(beta=beta_value))
```

이 코드는 TensorFlow를 사용하여 가중 크로스 엔트로피 손실 함수를 구현한 것입니다. `beta`는 False Negative에 대한 가중치를 조절하는 역할을 하며, 이 손실 함수를 모델 컴파일 시 사용하여 모델이 학습 과정 에서 False Negative를 줄이도록 유도합니다.

이 예시는 어떠한 질병의 진단에 있어서 False Negative를 줄이는 것이 중요한 의료적 상황에서 모델의 성능을 최적화하는 방법을 보여줍니다. 





---
# 문제 3.
### 시나리오: 에너지 소비 예측

#### 문제 상황
당신은 에너지 회사에서 일하며, 가정의 시간별 에너지 소비량을 예측하는 모델을 개발하고 있습니다. 이 모델은 다양한 가정에서 수집된 데이터를 기반으로 하루 24시간 동안의 에너지 사용 패턴을 예측합니다. 목표는 실제 에너지 사용량과 예측 사용량 사이의 차이를 최소화하는 것입니다. 특히, 모델이 예측하는 에너지 사용량의 변화율이 실제 변화율과 가능한 한 일치하도록 하고 싶습니다. 이는 에너지 공급 계획에 중요한 정보를 제공할 수 있기 때문입니다.

#### 목표
모델이 에너지 사용량의 시간에 따른 변화율을 정확하게 예측하도록 손실 함수를 설계하려고 합니다. 이를 위해 예측과 실제 값의 차이뿐만 아니라, 이들의 변화율 차이도 고려하는 손실 함수가 필요합니다.

### 손실 함수 설계: 적분 기반 변화율 손실

#### 공식
$\text{Integral Rate Loss} = \frac{1}{T} \int_{0}^{T} \left| \frac{d}{dt}(y(t) - \hat{y}(t)) \right| dt$
여기서:
- $T$는 예측 기간입니다 (예: 24시간).
- $y(t)$는 시간 $t$에서의 실제 에너지 사용량입니다.
- $\hat{y}(t)$는 시간 $t$에서의 예측 에너지 사용량입니다.
- $\frac{d}{dt}$는 시간에 대한 미분을 나타냅니다, 즉 변화율을 의미합니다.

#### 공식 해설
이 손실 함수는 실제 값과 예측 값 사이의 차이뿐만 아니라, 그 차이의 변화율도 고려합니다. 이는 모델이 에너지 사용량의 전반적인 양뿐만 아니라, 시간에 따른 변화 패턴도 정확하게 학습하도록 유도합니다. 변화율을 고려함으로써, 모델은 에너지 사용량이 급격히 증가하거나 감소하는 시간대를 더 정확하게 예측할 수 있습니다.

### 코드 구현 (PyTorch 예시)
PyTorch를 사용하여 이러한 손실 함수를 구현하는 예시입니다. 실제 구현에서는 적분 대신 적절한 수치적 방법을 사용하여 근사할 수 있습니다.

```python
import torch

def integral_rate_loss(y_true, y_pred):
    # 시간에 대한 변화율 계산 (근사)
    dy_true = torch.diff(y_true, dim=1)
    dy_pred = torch.diff(y_pred, dim=1)
    
    # 변화율 차이의 절대값 계산
    rate_loss = torch.abs(dy_true - dy_pred)
    
    # 평균 손실 반환
    return torch.mean(rate_loss)

# 예제 사용
# y_true, y_pred는 모델에서 예측한 값과 실제 값을 나타내는 텐서입니다

.
# 예를 들어, 이들은 [batch_size, time_series_length]의 형태를 가집니다.
```

이 구현은 시간에 따른 에너지 사용량의 변화율을 고려하여 손실을 계산합니다. `torch.diff` 함수는 텐서의 연속된 요소 간 차이를 계산하여 변화율을 근사합니다. 이 손실 함수는 에너지 소비 예측 모델이 시간에 따른 사용량의 변화 패턴을 더 정확하게 학습할 수 있도록 돕습니다.




---
# 문제 4.

### 시나리오: 시장 변동성 예측 모델 개발

#### 문제 상황
당신은 금융 기술 회사에서 근무하며, 주식, 채권, 상품 등 다양한 자산의 가격 변동성을 예측하는 머신러닝 모델을 개발하고 있습니다. 변동성 예측은 리스크 관리, 포트폴리오 최적화, 거래 전략 수립 등에 중요한 정보를 제공합니다. 이 모델의 목적은 향후 특정 기간 동안의 변동성을 정확하게 예측하는 것입니다. 특히, 실제 변동성이 예측한 변동성보다 훨씬 클 경우, 즉 시장의 급격한 변동을 놓치는 경우의 손실을 최대한 줄이고자 합니다.

#### 목표
모델이 실제 변동성이 예측한 변동성보다 클 경우, 이를 더 크게 패널티하는 손실 함수를 설계하려고 합니다. 이를 통해 모델이 시장의 급격한 변동을 더 잘 포착하도록 유도합니다.

### 손실 함수 설계: 변동성 가중 손실

#### 공식
$\text{Volatility Weighted Loss} = \frac{1}{N} \sum_{i=1}^{N} w_i (y_i - \hat{y}_i)^2$
여기서:
- $N$은 샘플의 수입니다.
- $y_i$는 시간 $i$에서의 실제 변동성입니다.
- $\hat{y}_i$는 시간 $i$에서의 예측 변동성입니다.
- $w_i$는 가중치로, 실제 변동성이 예측한 변동성보다 클 경우 더 큰 값을 가지며, 이는 $w_i = 1 + \alpha \times (y_i - \hat{y}_i)$으로 정의할 수 있습니다, 여기서 $\alpha$ 는 가중치 증가율을 조정하는 하이퍼파라미터입니다. $y_i > \hat{y}_i$ 일 때만 $w_i$ 가 1보다 크고, 그렇지 않으면 $w_i = 1$ 입니다.

#### 공식 해설
이 손실 함수는 실제 변동성이 예측 변동성보다 클 경우, 즉 시장의 급격한 움직임을 모델이 놓친 경우에 더 큰 패널티를 부과합니다. 이를 통해 모델이 시장의 급격한 변동을 더 정확하게 예측하도록 유도하며, 리스크 관리와 거래 전략 수립에 있어 더 신뢰할 수 있는 정보를 제공하게 됩니다.

### 코드 구현 (PyTorch 예시)

```python
import torch

def volatility_weighted_loss(y_true, y_pred, alpha=0.5):
    # 실제가 예측을 초과하는 경우에 대한 가중치 계산
    residuals = y_true - y_pred
    weights = 1 + alpha * torch.clamp(residuals, min=0)
    
    # 가중치가 적용된 MSE 계산
    loss = weights * (residuals ** 2)
    return torch.mean(loss)

# 예제 사용
# y_true, y_pred는 모델에서 예측한 값과

 실제 값을 나타내는 텐서입니다.
# 예를 들어, 이들은 [batch_size, features]의 형태를 가집니다.
```

이 코드는 PyTorch를 사용하여 변동성 가중 손실을 구현한 것입니다. `alpha` 파라미터를 조정하여 실제 변동성이 예측을 초과할 때 부과되는 패널티의 정도를 조절할 수 있습니다. 이 손실 함수를 사용함으로써, 모델은 시장 변동성을 보다 정확하게 예측하려는 경향을 가지게 됩니다, 특히 시장이 급격하게 움직일 때 이러한 예측은 매우 중요합니다.
