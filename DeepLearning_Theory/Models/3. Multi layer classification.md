

## 데이터 소개

- fashion MNIST 데이터 사용

![[3.Multi_layer_classification.png]]
이미지는 다음과 같은 것을 보여줍니다.
(a) 28 x 28의 배열에서 의류의 모습이 어떻게 모사되는지 
(b) 각 0-9까지의 다양한 의류 그림의 모습들 


## 최종 목표 
- fashion MNIST이미지를 classification 하기
- Multi class와 Multi label 구분하기 
- 이미지에 객체 삽입하기 
---


### 전처리 
``` python
"""
데이터 불러오기 
"""

fashion_mnist = keras.datasets.fashion_mnist
datasets = fashion_mnist.load_data()

(train_images, train_labels), (test_images, test_labels) = datasets
```


``` python
"""
레이블 설정 

https://www.kaggle.com/datasets/zalando-research/fashionmnist
"""

labels = ["T-shirt/top", # index 0
		  "Trouser",     # index 1
		  "Pullover",    # index 2
		  "Dress",       # index 3
		  "Coat",        # index 4
		  "Sandal",      # index 5
		  "Shirt",       # index 6
		  "Sneaker",     # index 7
		  "Bag",         # index 8
		  "Ankle boot"]  # index 9

def idx2label(idx):
	return labels[idx]
```


``` python
"""
이미지의 값이 가장 큰 idx와 작은 idx 출력
"""

train_images.reshape(shape = (60000, -1)).sum(axis = 1).argmax() # 55023
train_images.reshape(shape = (6000, -1)).sum(axis = 1).argmax()  # 9230

train_images.reshape(shape = (60000, -1)).sum(axis = 1)[55023]
train_images.reshape(shape = (60000, -1)).sum(axis = 1)[9230]
```


``` python
"""
정수형 데이터를 실수형으로 변경
"""

train_images = train_images.astype(np.float64)
test_images = test_images.astype(np.float64)
```


$$normalize(x) = \frac{x - 최소값}{최대값 - 최소값}$$
$$normalize(x) = \frac{x}{최대값}$$
``` python
"""
데이터 0-1 normalize 수행
"""

train_images = train_images / train_images.max()
test_images = test_images / test_images.max()

def norm(img):
	min_val = data.min()
	max_val = data.max()

	return (data - min_val) / (max_val - min_val)
```


``` python
"""
레이블에 따른 이미지 출력
"""

print(np.argwhere(train_labels == 9)[:5].shape) # (5, 1)

# 아래 셋은 같은 표현
print(np.argwhere(train_labels == 9)[:5].reshape(-1))
print(np.argwhere(train_labels == 9)[:5, 0])
print(np.argwhere(train_labels == 9)[:5, ..., 0])

"""
plt.imshow(train_images
		   [
			   np.argwhere(train_labels == 9)[:5, ..., 0]
		   ].transpose(1, 0, 2).reshape(28, -1))
"""

def filter(label, count=5):
	images = train_images
			[
				np.argwhere(train_labels == label)[:count, 0]
			].transpose(1, 0, 2).reshape(28, -1)
	
	plt.imshow(images)
	plt.show()

filter(0, 3)
```
---


### Data augmentation
``` python
"""
이미지 한장의 배셩 크기를 4배로 확대하고, 객체는 4분면 영역중 랜덤으로 한 공간에 넣는 함수
"""

def expand_4times(img):
	bg = np.zeros(img.shape)
	idx = np.random.randint(0, 4)
	
	slots = [bg, bg, bg, bg]
	slots[idx] = img

	expanded_img = np.vstack([
		np.hstack(slots[:2]),
		np.hstack(slots[2:])
	])

	return expanded_img


plt.imshow(expand_4times(train_images[0]))
plt.show()



train_expand_images = np.array([expand_4times(img) for img in train_images])
test_expand_images = np.array([expand_4times(img) for img in test_images])
```


``` python
"""
이미지 한장의 배경 크기를 4배로 확대하고, 객체를 랜덤으로 1 ~ 4개, 랜덤 4분면에 위치 시키는 함수
"""

def expand_4times2(x_data, y_data):
	images = []
	labels = []

	for _ in range(4):
		bg = np.zeros(shape = (28, 28))
		obj_count = np.random.randint(0, 5)
		label = np.zeros((10, ))
		slots = [bg, bg, bg, bg]

		for idx in range(obj_count):
			i = np.random.randint(len(x_data))

			slots[idx] = x_data[i]
			label += tf.keras.utils.to_categorical(y_data[i], 10)

			np.random.shuffle(slots)

	new_img = np.vstack([
		np.hstack(slots[:2]),
		np.hstack(slots[2:])
	])

	images.append(new_img)
	labels.append((label >= 1).astype(np.int8))

	return np.array(images), np.array(labels)



train_multi_images, train_multi_labels = list(zip(*[
		expand_4times2(train_images, train_labels) for _ in train_images]))


test_multi_images, test_multi_labels = list(zip(*[
		expand_4times2(test_images, test_labels) for _ in test_images]))



print(np.array(train_multi_images).shape)      # (60000, 1, 56, 56)
np.array(train_multi_images[:, 0, :, :]).shape # (60000, 56, 56)

print(np.array(train_multi_labels).shape)      # (60000, 1, 10)
np.array(train_multi_labels[:, 0, :]).shape    # (60000, 10)
```


``` python
"""
4차원 데이터 처리
"""

# (60000, 56, 56, 1)
train_multi_images = 
			np.array(train_multi_images)[:, 0, :, :].reshape(-1, 56, 56 ,1)

# (60000, 10)
train_multi_labels = 
			np.array(train_multi_labels)[:, 0, :]


test_multi_images =
			np.array(test_multi_images)[:, 0, :, :].reshape(-1, 56, 56 ,1)
test_multi_labels = 
			np.array(test_multi_labels)[:, 0, :]
```


``` python
"""
의류 갯수에 따라 연속된 그림 보여주는 함수
"""
def filter2(obj_count, count = 5):
	labels = train_multi_labels.sum(axis = 1)

	idx = np.argwhere(labels == obj_count)[:count, 0]

	imgs = train_multi_images[idx][
									..., 
									0].transpose(1, 0, 2).reshape(56, -1)
	plt.imshow(imgs)
	plt.show()


filter2(1, 5)
```
---


### 모델링 
``` python
from keras.layers import Input, Conv2D, MaxPool2D, Dropout, Dense, Flatten
from keras.models import Model 

def single_fashon_mnist_model():
	inputs = Input(shape = (56, 56, 1))
	x = Conv2D(filters=16)
```














