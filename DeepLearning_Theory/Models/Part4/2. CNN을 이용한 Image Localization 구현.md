

# 데이터셋 경로 설정
``` python
"""
이미지 데터와 bounding box 데이터 갯수 확인
"""

cur_dir = os.getcwd() 
data_dir = os.path.join(cur_dir, 'datasets/oxford_pet')
image_dir = os.path.join(data_dir, 'images')

# 모든 운영체제에 맞추려면 따로 쓰는게 좋다
bbox_dir = os.path.join(image_dir, 'annotations', 'xmls')

# 리스트 컴프리헨션
image_files = [fname for fname in os.listdir(image_dir) 
										if os.path.splitext(fname)[-1] == 'jpg']

"""
- os.getcwd() 함수는 현재 작업중인 디렉토리의 경로를 반환

- os.listdir(path) 함수는 지정된 경로의 디렉토리 내 모든 파일과 디렉토리 목록을 반환

- os.path.splitext() 함수는 파일 이름을 이름과 확장자로 분리 [0]은 파일 이름, [-1]은 확장자
"""

bbox_file = [fname for fname in os.listdir(bbox_dir) 
										if os.path.splitext(fname)[-1] == 'xml']
n_bboxes = len(bbox_file)
```


# 데이터 확인
``` python
# n_bboxes는 길이니까 -1 (8 = 0 ~ 7)
rnd_idx = random.randint(0, n_bboxes - 1) 

bbox_name = bbox_files[rnd_idx]
bbox_path = os.path.join(bbox_dir, bbox_name)
"""
xml.etree.ElementTree 모듈의 축약형
XML파일 구조를 읽고 그 구조를 트리 형태의 데이터 구조로 변환
"""
tree = et.parse(bbox_path)

# .text속성은 해당 요소의 텍스트 내용을 나타냄(ex) <xmin>100</xmin> => 문자열 100 반환
xmin = float(tree.find('./object/bndbox/xmin').text)
ymin = float(tree.find('./object/bndbox/ymin').text)
xmax = float(tree.find('./object/bndbox/xmax').text)
ymax = float(tree.find('./object/bndbox/ymax').text)

rect_x = xmin
rect_y = ymin

rect_w = xmax - xmin
rect_h = ymax - ymin

fname = os.path.splitext(bbox_name)[0] + '.jpg'
fpath = os.path.join(image_dir, fname)
image = Image.open(fpath)
image = np.array(image)

"""
Rectangle((x, y), width, height ,angle, fill, color, ...)
	- xy: (필수) 사각형의 왼쪽 하단 모서리 좌표를 나타내며 튜플 형태로 `(x, y)`를 입력
    
	- width: (필수) 사각형의 너비
    
	- height: (필수) 사각형의 높이
    
	- angle: 사각형의 회전 각도. 기본값은 0
    
	- fill: 사각형 내부를 채울지 여부를 결정. `True` 또는 `False`로 설정할 수 있으며, 
		    기본값은 `True`
    
	- color: 사각형의 테두리 및 내부 색상을 지정. 색상은 이름, 헥사코드, RGB 튜플 등 
			 다양한 방식으로 지정할 수 있다.


plt.axis() : 현재 활성화된 축 객체를 반환하거나 새로운 축 객체를 생성
			 여기서는 새로운 축 객체를 생성하고 이를 반환

.add_patch(rect) : axes 객체에 패치(여기서는 Rectangle 객체인 rect)를 추가
				   이를 통해 rect로 정의된 사각형이 해당 축에 그려진다.
"""
rect = Rectangle((rect_x, rect_y), rect_w, rect_h, fill = False, color = 'red')
plt.axes().add_patch(rect)
plt.imshow(image)
plt.show()


"""
재미있는 점
- TensorFlow에서의 이미지 처리 시 xmin, ymin은 왼쪽 상단 

- Matplotlib에서의 Rectangle 처리시 xmin, ymin은 왼쪽 하단
"""
```


# RGB 외의 data 삭제
``` python
for image_file in image_files:
	image_path = os.path.join(image_dir, image_file)
	bbox_file = os.path.splitext(image_file)[0] + '.xml'
	bbox_path = os.path.join(bbox_dir, bbox_file)

	
	"""
	PIL Image객체를 반환 받은 image의 mode 속성은 해당 이미지 객체의 색상모드를 나타낸다.

	- RGB : 표준 RGB 색상 모드
	- RGBA : 알파 채널(투명도)이 추가된 모드
	- L : 흑백 이미지를 나타내는 단일 채널 모드 L은 빛의 발기를 나타냄
	- CMYK : 시안 마젠타, 노랑, 검정 채널을 가진 인쇄용 색상 모드
	- P : 팔레트 모드로, 픽셀 값이 색상 팔레트의 인덱스를 참조

	PIL/Pillow Image 객체의 주요 method 및 속성
	- show() 
		- 이미지를 기본 뷰어에서 보여준다.
	- save(filename, format=None, **params)
		- format은 이미지 포맷 지정
	- resize((width, height), resample-0)

	- rotate(angle, resample=0, expand=0)

	- crop(box=None)
		- 이미지의 일부를 잘라내 새 이미지 생성 box 는 (left, upper, right, lower) 튜플
	- convert(mode=None, **params)
		- 이미지 색상 모드 변경
	- filter(filter)
		- 블러 컨투어 등 다양한 필터 적용
	- getpixel((x, y))
		- 지정된 좌표에 있는 픽셀의 색상값 반환
	- size
		- 이미지의 크기를 (너비, 높이) 형태의 튜플로 반환
	- format
		- 이미지가 로드된 파일의 포멧(JPEG, PNG)를 나타냄
	"""
	image = Image.open(image_path)
	image_mode = image.mode

	if image_mode != 'RGB':
		# np.asarray 함수는 주어진 객체를 numpy 배열로 변환
		image = np.asarray(image)
		print(image.shape)
		# 지정된 경로의 파일을 삭제
		os.remove(image_path)

		try:
			os.remove(bbox_path)
		except FileNotFoundError:
			pass
```


# tfrecord 파일 만들기
``` python
IMG_SIZE = 224
N_DATA = 3685
N_TRAIN = 3000
N_VAL = 685

# train/validation data 나누기 
shuffle_list = list(range(N_DATA))
random.shuffle(shuffle_list)

train_idx_list = shuffle_list[:N_TRAIN]
val_idx_list = shuffle_list[N_TRAIN:]

# tfrecord writer 생성 
tfr_dir = os.path.join(data_dir, 'tfrecord')
					# 해당 경로에 디렉토리가 이미 존재하면 패스
os.makedir(tfr_dir, exist_ok = True)

tfr_train_dir = os.path.join(tfr_dir, 'loc_train.tfr')
tfr_val_dir = os.path.join(tfr_dir, 'loc_val.tfr')


"""
tf.io.TFRecordWriter 함수는 지정된 경로에 TFRecord파일을 생성하고 작성하기 위한 TFRecordWriter객체를 생성한다. 

TFRecord는 TensorFlow에서 사용되는 바이너리 파일 형식으로, 효율적인 데이터 읽기/쓰기를 위해 설계되었으며, 이 형식은 대규모 데이터셋, 특히 이미지나 텍스트 데이터셋을 저장하고 효율적으로 읽기 위해 자주 사용된다.

writer_train/val 객체는 TFRecord파일에 데이터를 쓰기 위한 인테페이스를 제공한다.
이 객체를 사용하여 데이터를 TFRecord형식으로 직렬화하고 파일에 쓸 수 있다. 
주로 writer_train/val.write(example) 메서드를 사용해 직룔화된 데이터를 파일에 쓰게된다.
"""
writer_train = tf.io.TFRecordWriter(tfr_train_dir)
writer_val = tf.io.TFRecordWriter(tfr_val_dir)
```

# tfrecord 파일 작성
``` python
def _bytes_feature(value):
	""" 
	value가 Tensorflow의 EagerTensor인지 확인 
	EagerTensor인 경우 .numpy()를 사용하여 numpy배열로 변환
	이는 BytesList가 EagerTensor에서 직접 문자열을 언패킹 하지 않기 때문

	isinstance(1, int) = True
	isinstance(1.2, int) = False
	"""
	if isinstance(value, type(tf.constant(0))):
		value = value.numpy()
	return tf.train.Feature(bytes_list = tf.train.BytesList(value=[value]))

	"""
	tf.train.Feature를 사용해 바이너리 데이터(예: 이미지 데이터)를 TFRecord파일에 저장하기
	위해 변환하는 과정 

	- tf.train.BytesList(value=[value]) 
		BytesList 타입의 프로토콜 버퍼를 생성.
		프로토콜 버퍼는 구글이 개발한 데이터 직렬화 도구로, 복잡한 데이터 구조를 효율적으로 저장하고 
		전송할 수 있게 해준다.

		ByteList 는 바이너리 데이터(예: 문자열, 이미지 등)를 나타내는데 사용된다. 
		여기서 value는 바이트 문자열이나 이미지 바이트 등을 나타낸다 
		
		value = [value] 는 value를 리스트 형태로 감짜준다.BytesList는 하나 이상의 값을 
		포함할 수 있으므로, 심지어 단일값일 경우에도 리스트 형태로 제공된다.

	- tf.train.Feature
		Feature는 Tensorflow에서 사용하는 또 다른 프로토콜 버퍼 타입.
		
		Feature는 다양한 데이터 타입(BytesList, FloatList, Int64List 등)을 저장할수 있는 
		일반적인 컨테이너

		여기서 tf.train.Feature(bytes_list = tf.train.BytesList(value=[value]))는
		바이너리 데이터를 저장하기 위한 BytesList를 Feature로 감싸는 과정을 나타낸다.
	"""

def _float_feature(value):
	return tf.train.Feature(float_list = tf.train_FloatList(value=[value]))

def _int64_feature(value):
	return tf.train.Feature(int64_list = tf.train.Int64List(value=[value]))

```


``` python
for idx in val_idx_list:
	bbox_file = bbox_files[idx]
	bbox_path = os.path.join(bbox_dir, bbox_file)

	tree = tf.parse(bbox_path)
	width = float(tree.find('./size/width').text)
	height = float(tree.find('./size/height').text)
	
	xmin = float(tree.find('./object/bndbox/xmin').text)
	ymin = float(tree.find('./object/bndbox/ymin').text)
	xmax = float(tree.find('./object/bndbox/xmax').text)
	ymax = float(tree.find('./object/bndbox/ymax').text)

	xc = (xmin + xmax) / 2
	yc = (ymin + ymax) / 2

	x = xc / width  # 이미지 크기에 비례하도록 정규화
	y = yc / height 

	w = (xmax - xmin) / width  # 이미지 크기에 비례하도록 너비 정규화
	h = (ymax - ymin) / height

"""
간단한 예시

- 가정: 이미지의 크기가 100x100픽셀이고, 어떤 사각형(바운딩 박스)의 좌표가 
	   `(xmin=30, ymin=40, xmax=60, ymax=80)`라고 합시다.
- 이 사각형의 중심점은 `(45, 60)`이 됩니다. (`(30+60)/2 = 45`, `(40+80)/2 = 60`)

- 이 중심점을 이미지 크기에 맞게 정규화하면 `(0.45, 0.60)`이 됩니다. 
  (`45/100 = 0.45`, `60/100 = 0.60`)

- 사각형의 너비와 높이는 각각 30픽셀(`60-30`)과 40픽셀(`80-40`)입니다.

- 이를 정규화하면 `(0.30, 0.40)`이 됩니다. (`30/100 = 0.30`, `40/100 = 0.40`)

즉 바운딩 박스를 정규화 한다는 것은 좌표를 확률로 만들어서 1000px든 100px든 
상단 40% 하단 20% 같이 확률적으로 나타내기 위해 사용
"""

	file_name = os.path.splitext(bbox_file)[0]
	image_file = file_name + '.jpg'
	image_path = os.path.join(image_dir, image_file)

	image = Image.open(image_path)
	image = image.resize((IMG_SIZE, IMG_SIZE))

	bimage = image.tobytes()
"""
tobytes 메서드는 이미지를 바이트 형식(이진화)으로 변환한다. 
즉 이미지 데이터를 연속된 바이트 시퀀스로 변환

바이트 형식 데이터는 파일로 저장하거나 네트워크를 통해 전송하기 적합한 형태

이미지는 원래 픽셀의 배열이나 행렬 구조로 되어 있지만 바이트 변환 후에는 이러한 구조 없이 단순한 
바이트 스트림으로 존재

ex)
- 비주얼 예시: 파일을 열어보면, `01010100 01101000 01101001 01110011`와 같은 2진수 형태가 
		    아닌, `54 68 69 73`와 같은 16진수 형태로 보임
    
- 실제 데이터: 예를 들어, RGB 이미지에서 한 픽셀이 빨간색(`R=255, G=0, B=0`)인 경우, 
			이 픽셀은 `FF 00 00`의 3바이트로 표현
"""

	if file_name[0].islower():
		cls_num = 0 # 개
	else:
		cls_num = 1 # 고양이

	example = tf.train.Example(features = tf.train.Features(feature = {
		'image': _bytes_feature(bimage),
		'cls_num': _int64_feature(cls_num),
		'x': _float_feature(x),
		'y': _float_feature(y),
		'w': _float_feature(w),
		'h': _float_feature(h)
	}))
	"""
	- tf.train.Example 은 Tensroflow에서 제공하는 데이터 타입으로, 훈련 데이터를 표현하기 위한 
	일반적인 포멧. Example은 key-value 쌍의 딕셔너리 형태로 데이터를 저장 

	- features = tf.train.Features(feature = {...}) 
	tf.train.Features는 하나 이상의 key-value 쌍('feature')를 포함
	각 키는 문자열이고 값은 tf.train.Feature 객체

	_bytes_feature, _int64_feature, _float_feature 함수들은 앞서 정의된 헬퍼 함수들로
	각각 바이트 데이터, 정수 데이터, 부동소수점 데이터를 tf.train.Feature형식으로 변환
	"""

	writer_train.write(example.SerializeToString())
	"""
	- example.SerializeToString():
	SerializeToString 메서드는 Example 객체를 문자열 형태의 직렬화된 데이터로 변환
	"""

writer_train.close()
```


# Image Localization 모델 작성 및 학습
``` python
N_EPOCHS = 40
N_BATCH = 40
N_VAL_BATCH = 127
learning_rate = 0.0001

def _parse_function(tfrecord_serialized):
	features = {'image':tf.io.FixedLenFeature([], tf.string),
				'cls_num': tf.io.FixedLenFeature([], tf.int64),
				'x': tf.io.FixedLenFeature([], tf.float32),
				'y': tf.io.FixedLenFeature([], tf.float32),
				'w': tf.io.FixedLenFeature([], tf.float32),
				'h': tf.io.FixedLenFeature([], tf.float32),
				}

	parsed_features = tf.io.parse_single_example(tfrecord_serialized, features)

	image = tf.io.decode_raw(parsed_features['image'], tf.uint8
	"""
	`parsed_features['image']`에 저장된 바이트 형식의 데이터를 `uint8` 형식으로 디코딩 
	여기서 `parsed_features['image']`는 TFRecord에서 추출된 이미지 데이터를 바이트 형식으로 
	포함하고 있으며, 이를 실제 이미지 데이터로 변환하기 위해 `tf.io.decode_raw` 함수를 사용
	"""
	image = tf.reshape(image, [IMG_SIZE, IMG_SIZE, 3])
	"""
	디코딩된 이미지 데이터를 원하는 형태로 재구성 
	여기서 `[IMG_SIZE, IMG_SIZE, 3]`은 이미지의 높이, 너비, 
	그리고 채널 수(여기서는 3채널, 일반적으로 RGB 이미지를 의미)를 나타낸다. 
	"""
	image = tf.cast(image, tf.float32) / 255.
	"""
	이미지 데이터를 `float32` 형식으로 변환하고 0과 1 사이의 값으로 정규화. 
	일반적으로 이미지 데이터는 0부터 255까지의 정수 값을 가지므로, 이를 255로 나누어 0과 1 사이의 
	부동소수점 값으로 변환 
	"""
	
	x = tf.cast(parsed_features['x'], tf.float32)
	y = tf.cast(parsed_features['y'], tf.float32)
	w = tf.cast(parsed_features['w'], tf.float32)
	h = tf.cast(parsed_features['h'], tf.float32)
	gt = tf.stack([x, y, w, h], -1) # [0.381 0.5015015 0.534 0.8408408]
	# x, y, w, h가 현재는 스칼라 이므로 -1이 있으나 없으나 똑같은 결과 나옴

	return image, gt
```

