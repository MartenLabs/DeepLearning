
``` python
import torch
```

### 텐서 초기화 

데이터로부터 직접 텐서 생성

``` python
data = [[1, 2], [3, 4]]
x_data = torch.tensor(data)
```


### Numpy 배열로부터 생성 

반대도 가능

``` python
np_array = np.array(data)
x_np = torch.from_numpy(np_array)
```


### 다른 텐서로부터 생성

명시적으로 재정의 하지 않는다면, 인자로 주어진 텐서의 속성(모양(shape), 자료형(datatype))을 유지 

``` python
# x_data의 속성 유지
x_ones = torch.ones_like(x_data) 

# x_data의 속성 덮어씀(자료형 바뀜)
x_rand = torch.rand_like(x_data, dtype = torch.float)


"""
Ones Tensor: 
tensor([[1, 1], 
	   [1, 1]]) 
	
Random Tensor: 
tensor([[0.1410, 0.6257], 
       [0.3737, 0.3467]])
"""
```


### 무작위(random) 또는 상수(constant) 값 사용

shape은 텐서의 차원(dimension)을 나타내는 튜플(tuple)로, 아래 함수들에서는 출력 텐서의 차원을 결정

``` python
shape = (2, 3,)
rand_tensor = torch.rand(shape)
ones_tensor = torch.ones(shape)
zeros_tensor = torch.zeros(shape)

"""
Random Tensor: 
 tensor([[0.1705, 0.4169, 0.7231],
        [0.5942, 0.1188, 0.5520]]) 

Ones Tensor: 
 tensor([[1., 1., 1.],
        [1., 1., 1.]]) 

Zeros Tensor: 
 tensor([[0., 0., 0.],
        [0., 0., 0.]])
"""
```



### 텐서의 속성(Attribute)

텐서의 속성은 텐서의 모양(shape), 자료형(datatype) 및 어느 장치에 저장 되는지를 나타낸다.

``` python
tensor = torch.rand(3, 4)

"""
Shape of tensor: torch.Size([3, 4])
Datatype of tensor: torch.float32
Device tensor is stored on: cpu
"""
```



### 텐서 연산 (Operation)

기본적으로 텐서는 CPU에 생성되지만 .to 메소드를 사용해 GPU로 텐서를 명시적으로 이동 가능. 

``` python
if torch.cude.is_available():
	tensor = tensor.to("cuda")
```



### NumPy식의 표준 인덱싱과 슬라이싱
``` python
tensor = torch.rand(4, 4)
print(tensor)
print(f"First row: {tensor[0]}")
print(f"First column: {tensor[:, 0]}")
print(f"Last column: {tensor[..., -1]}")
tensor[:, 1] = 0
print(tensor)


"""
tensor([[0.2662, 0.6929, 0.5385, 0.4480],
        [0.0499, 0.6138, 0.8756, 0.9174],
        [0.8447, 0.6677, 0.0407, 0.8491],
        [0.9659, 0.2635, 0.1464, 0.4120]])
        
First row: tensor([0.2662, 0.6929, 0.5385, 0.4480])

First column: tensor([0.2662, 0.0499, 0.8447, 0.9659])

Last column: tensor([0.4480, 0.9174, 0.8491, 0.4120])

tensor([[0.2662, 0.0000, 0.5385, 0.4480],
        [0.0499, 0.0000, 0.8756, 0.9174],
        [0.8447, 0.0000, 0.0407, 0.8491],
        [0.9659, 0.0000, 0.1464, 0.4120]])
"""
```


텐서 합치기 torch.cat을 사용하여 주어진 차원에 따라 일련의 텐서를 연결 할 수 있다.
``` python
# dim == axis (0: 행방향, 1 열방향)
t1 = torch.cat([tensor, tensor, tensor], dim = 0)

"""
tensor([[0.2662, 0.0000, 0.5385, 0.4480],
        [0.0499, 0.0000, 0.8756, 0.9174],
        [0.8447, 0.0000, 0.0407, 0.8491],
        [0.9659, 0.0000, 0.1464, 0.4120],
        [0.2662, 0.0000, 0.5385, 0.4480],
        [0.0499, 0.0000, 0.8756, 0.9174],
        [0.8447, 0.0000, 0.0407, 0.8491],
        [0.9659, 0.0000, 0.1464, 0.4120],
        [0.2662, 0.0000, 0.5385, 0.4480],
        [0.0499, 0.0000, 0.8756, 0.9174],
        [0.8447, 0.0000, 0.0407, 0.8491],
        [0.9659, 0.0000, 0.1464, 0.4120]])

"""


t1 = torch.cat([tensor, tensor, tensor], dim = 1)

"""
tensor([[0.6314, 0.0000, 0.6446, 0.6860, 0.6314, 0.0000, 0.6446, 0.6860, 0.6314, 0.0000, 0.6446, 0.6860],
        [0.8336, 0.0000, 0.3110, 0.4294, 0.8336, 0.0000, 0.3110, 0.4294, 0.8336, 0.0000, 0.3110, 0.4294],
        [0.6410, 0.0000, 0.5801, 0.7467, 0.6410, 0.0000, 0.5801, 0.7467, 0.6410, 0.0000, 0.5801, 0.7467],
        [0.7296, 0.0000, 0.5763, 0.5586, 0.7296, 0.0000, 0.5763, 0.5586, 0.7296, 0.0000, 0.5763, 0.5586]])

"""
```




### 산술 연산(Arithmetic operations)
``` python
# 두 텐서 간의 행렬 곱 (y1 == y2 == y3)
y1 = tensor @ tensor.T
y2 = tensor.matmul(tensor.T)
y3 = torch.rand_like(y1)
torch.matmul(tensor, tensor.T, out = y3)

# 요소별 곱(element-wise product)
z1 = tensor * tensor
z2 = tensor.mul(tensor)
z3 = torch.rand_like(tensor)
torch.mul(tensor, tensor, out = z3)
```




### 단일-요소(single-element)텐서 

텐서의 모든 값을 하나로 집계(aggregate)하여 요소가 하나인 텐서의 경우, item()을 사용하여 python숫자 값으로 변환

``` python
agg = tensor.sum()
agg_item = agg.item()
print(agg_item, type(agg_item))

"""
7.36817741394043 <class 'float'>
"""
```



### 바꿔치기(in-place) 연산 (권장 X)

연산 결과를 피연산자(operand)에 저장하는 연산을 바꿔치기 연산이라 부르며 _ 접미사를 갖는다. ex) x.copy_(y)나 x.t_() 는 x에 할당 없이 x를 직접 변경

``` python
print(f"{tensor} \n")
tensor.add_(5)
print(tensor)

"""
tensor([[0.6314, 0.0000, 0.6446, 0.6860],
        [0.8336, 0.0000, 0.3110, 0.4294],
        [0.6410, 0.0000, 0.5801, 0.7467],
        [0.7296, 0.0000, 0.5763, 0.5586]]) 

tensor([[5.6314, 5.0000, 5.6446, 5.6860],
        [5.8336, 5.0000, 5.3110, 5.4294],
        [5.6410, 5.0000, 5.5801, 5.7467],
        [5.7296, 5.0000, 5.5763, 5.5586]])

"""
```



### NumPy 변환(Bridge)

CPU 상의 텐서와 NumPy 배열은 메모리 공간을 공유하기 때문에, 하나를 변경하면 다른 하나도 변경

- 텐서를 NumPy배열로 변환 
``` python
t = torch.ones(5)
print(f"t: {t}")
n = t.numpy()
print(f"n: {n}")

"""
t: tensor([1., 1., 1., 1., 1.])
n: [1. 1. 1. 1. 1.]
"""
```

- 텐서의 변경 사항이 NumPy 배열에 반영
``` python
t.add_(1)
print(f"t: {t}")
print(f"n: {n}")
```

- NumPy 배열을 텐서로 변환
``` python
n = np.ones(5)
t = torch.from_numpy(n)
```

- NumPy 배열의 변경사항이 텐서에 반영 
``` python
np.add(n, 1, out = n)
print(f"t: {t}")
print(f"n: {n}")


"""
t: tensor([2., 2., 2., 2., 2.], dtype=torch.float64)
n: [2. 2. 2. 2. 2.]
"""
```




### Dataset과 DataLoader

데이터 샘플을 처리하는 코드는 지저분하고 유지보수가 어려울 수 있다. 더 나은 가독성 과 모듈성 을 위해 데이터셋 코드를 모델 학습 코드로부터 분리하는 것이 이상적이다. 

PyTorch는 torch.utils.data.DataLoader와 torch.utils.data.Dataset 의 두가지 데이터 기본 요소를 제공하여 미리 준비해둔(pre-loaded) 데이터셋 뿐만 아니라 가지고 있는 데이터를 사용할 수 있도록 한다. 
Dataset은 샘플과 정답(label)을 저장하고, DataLoader 는 Dataset을 샘플에 쉽게 접근할 수 있도록 순회 가능한 객체(iterable)로 감싼다.


PyTorch의 도메인 특화 라이브러리들은 (FashionMNIST와 같은) 미리 준비해둔(pre-loaded) 다양한 데이터셋을 제공한다. 데이터셋은 torch.utils.data.Dataset의 하위 클래스로 개별 데이터를 특정하는 함수가 구현되어 있다. 이러한 데이터셋은 모델을 만들어보고(prototype) 성능을 측정 (benchmark)하는데 사용할 수 있다



### 데이터셋 불러오기 

- root : 학습/테스트 데이터가 저장되는 경로
- train : 학습용 또는 테스트용 데이터셋 여부를 지정 
- download = True : root에 데이터가 없는 경우 인터넷에서 다운로드 
- transform, target_transform : feature와 label 변형을 지정

``` python
import torch
from torch.utils.data import Dataset
from torchvision import datasets
from torchvision.transforms import ToTensor
import matplotlib.pyplot as plt

training_data = datasets.FashionMNIST(
	root = "data",
	train = True,
	download = True,
	transform = ToTensor()
)

test_data = datasets.FashionMNIST(
	root = "data",
	train = False,
	download = True,
	transform = ToTensor()
)
```



### 데이터셋을 순회하고 시각화 

Dataset에 리스트 처럼 직접 접근(index)할 수 있다.
training_data[index].matplotlib을 사용해 학습 데이터의 일부를 시각화

``` python
labels_map = {
	0: "T-Shirt",
	1: "Trouser",
	2: "Pullover",
	3: "Dress",
	4: "Coat",
	5: "Sandal",
	6: "Shirt",
	7: "Sneaker",
	8: "Bag"
	9: "Ankle Boot", 
}

figure = plt.figure(figsize = (8, 8))
cols, rows = 3, 3
for i in range(1, cols * rows + 1):
	sample_idx = torch.randint(len(training_data), size = (1,)).item()
	img, label = training_data[sample_idx]
	figure.add_subplot(rows, cols, i)
	plt.title(labels_map[label])
	plt.axis("off")

	# img shape = (1, 28, 28)
	# img.squeeze().shape = (28, 28)
	plt.imshow(img.squeeze(), cmap = 'gray')
plt.show()
```



### 파일에서 사용자 정의 데이터셋 만들기

사용자 정의 Dataset 클래스는 반드시 3개 함수를 구현해야 한다. 

#### `__init__`,  `__len__`, `__getitem__`

아래 구현을 살펴보면 FashionMNIST 이미지들은 img_dir 디렉토리에 저장되고, 정답은 annotations_file csv 파일에 별도로 저장된다.

[아래 분할하여 자세히 설명]
``` python
import os 
import pandas as pd 
from torchvision.io import read_image

class CustomImageDataset(Dataset):
	def __init__(self, annotations_file, img_dir, transform=None, target_transform=None):
	self.img_labels = pd.read_csv(annotations_file, names=['file_name', 'label'])
	self.img_dir = img_dir
	self.transform = transform
	self.target_transform = target_transform


	def __len__(self):
		return len(self.img_labels)

	def __getitem__(self, idx):
	"""
	`self.img_labels`가 이미지 파일 이름을 포함하는 열과 해당 이미지의 레이블을 포함하는 열을 가지고 있다면, 
	`self.img_labels.iloc[idx, 0]`는 `idx`에 해당하는 이미지 파일의 이름을 반환. 
	이 이름은 후속 코드 `os.path.join(self.img_dir, self.img_labels.iloc[idx, 0])`에서 이미지 파일의 전체 경로를 구성하는 데 사용 
	여기서 `self.img_dir`은 이미지 파일들이 저장된 디렉토리의 경로를 나타냅니다.
	"""
		img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0])
		image = read_image(img_path)
		label = self.img_labels.iloc[idx, 1]
		if self.transform:
			image = self.transform(image)
		if self.target_transform:
			label = self.target_transform(label)
		return image, label
```



### `__init__`

`__init__` 함수는 Dataset 객체가 생성(instantiate)될 때 한 번만 실행
여기서는 이미지와 주석 파일(annotation_file)이 포함된 디렉토리와 두가지 변형(transform)을 초기화

labels.csv ex) 

	tshirt1.jpg,   0
	tshirt2.jpg,   0
	......
	ankleboot999.jpg,   9

``` python
def __init__(self, annotations_file, img_dir, transform=None, target_transform=None):
	self.img_labels = pd.read_csv(annotations_file)
	self.img_dir = img_dir
	self.transform = transform
	self.target_transform = target_transform
```



### `__len__`

`__len__` 함수는 데이터셋의 샘플 개수를 반환 

``` python
def __len__(self):
	return len(self.img_labels)
```



### `__getitem__`

`__getitem__` 함수는 주어진 인덱스 idx에 해당하는 샘플을 데이터셋에서 불러오고 반환 
인덱스를 기반으로, 디스크에서 이미지의 위치를 식별하고, read_image를 사용하여 이미지를 텐서로 변환하고, self.img_labels의 csv 데이터로부터 해당하는 정답(label)을 가져오고, (해당하는 경우) 변형(transform) 함수들을 호출한 뒤, 텐서 이미지와 라벨을 Python 사전(dict) 형으로 반환 

``` python
def __getitem__(self, idx):
	img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0])
	image = read_image(img_path)
	label = self.img_labels.iloc[idx, 1]
	if self.transform:
		image = self.transform(image)
	if self.target_transform:
		label = self.target_transform(label)
	sample = {"image" : image, "label" : label}
	return sample
```




### DataLoader로 학습용 데이터 준비 

Dataset은 데이터셋의 특징(feature)을 가져오고 하나의 샘플에 정답(label)을 지정하는 일을 한번에 수행. 
모델을 학습할 때, 일반적으로 샘플들을 "minibatch"로 전달하고, 매 에폭(epoch)마다 데이터를 다시 섞어 과적합(overfit)을 막고, Python의 multiprocessing을 사용하여 데이터 검색 속도를 높힌다.

DataLoader는 간단한 API로 이러한 복잡한 과정들을 추상화한 순회 가능한 객체(iterable)이다.

``` python
from torch.utils.data import DataLoader

train_dataloader = DataLoader(training_data, batch_size = 64, shuffle = True)
test_dataloader = DataLoader(test_data, batch_size = 64, shuffle = True)
```



### DataLoader를 통해 순회(iterate)

DataLoader에 데이터셋을 불러온 뒤에는 필요에 따라 데이터셋을 순회(iterate)할 수 있다. 아래의 각 순회(iteration)는 (각각 batch_size=64) 의 특징(feature)과 정답(label)을 포함하는) train_features와 train_labels 의 묶음(batch)을 반환한다. 
shuffle = True로 지정했으므로, 모든 배치를 순회한 뒤 데이터가 섞인다.

``` python
train_features, train_labels = next(iter(train_dataloader))
print(f"Feature batch shape: {train_features.size()}")
print(f"Labels batch shape: {train_labels.size()}")

img = train_features[0].squeeze()
label = train_labels[0]
plt.imshow(img, cmap = 'gray')
plt.show()
print(f"Label: {label}")

"""
Feature batch shape: torch.Size([64, 1, 28, 28])
Labels batch shape: torch.Size([64])
"""
```




### Transform

데이터가 항상 머신러닝 알고리즘 학습에 필요한 최종 처리가 된 형태로 제공되지는 않는다.
변형(Transform)을 해서 데이터를 조작하고 학습에 적합하게 만든다. 

모든 TorchVision 데이터셋들은 변형 로직을 갖는, 호출 가능한 객체(callable)를 받는 매개변수 두개 ( 특징(feature)을 변형하기 위한 transform과 정답(label)을 변경하기 위한 target_transform)를 갖는다. 

FashionMNIST 특정(feature)은 PIL Image형식이며, 정답(label)은 정수(intefer)이다. 
학습을 하려면 정규화(normalize)된 텐서 형태의 특징(feature)과 one-hot으로 encoding된 텐서 형태의 정답(label)이 필요하다. 이러한 변형(transformation)을 하기 위해 ToTensor와 Lambda를 사용

``` python
import torch 
from torchvision import datasets
from torchvision.transforms import ToTensor, Lambda

ds = datasets.FashionMNIST(
	root = 'data',
	train = True,
	download = True,
	# `transform=ToTensor()`는 PyTorch의 `torchvision.transforms` 모듈에 있는 `ToTensor` 변환을 의미
	# 이 변환을 사용하면 이미지 데이터를 PyTorch의 텐서(tensor)로 변환하고, 동시에 이미지의 픽셀 값 범위를 [0, 255]에서 [0.0, 1.0]으로 정규화
	transform=ToTensor(),
	# y 값은 0 ~ 9 사이
	# 레이블 y를 받아 해당 레이블에 해당하는 위치를 제외하고 모두 0이며, 레이블 위치만 1인 10차원의 one-hot 인코딩 벡터를 생성하는 함수
	target_transform = Lambda(lambda y: torch.zeros(10, dtype=torch.float).scatter_(dim = 0, index = torch.tensor(y), value = 1))
)
```
##### 구조 분석
1. **Lambda**:
   - `Lambda`는 `torchvision.transforms` 모듈의 기능 중 하나로, 사용자 정의 람다(lambda) 함수를 변환(transform)으로 사용할 수 있게 해줍니다. 이를 통해 레이블 데이터에 대한 임의의 변환을 정의할 수 있습니다.

2. **lambda 함수**:
   - `lambda y: ...`는 레이블 `y`를 입력으로 받는 람다 함수를 정의합니다. 이 함수는 `y`에 대해 특정 변환을 수행한 결과를 반환합니다.

3. **torch.zeros(10, dtype=torch.float)**:
   - `torch.zeros(10, dtype=torch.float)`는 길이가 10이고, 모든 요소가 0인 부동소수점 타입의 텐서를 생성합니다. 이 텐서는 원-핫 인코딩된 벡터의 기반이 됩니다. 길이 10은 클래스의 개수를 가정한 것으로, 분류하려는 타겟 클래스가 10개라는 것을 의미합니다.

4. **scatter_(0, torch.tensor(y), value=1)**:
   - `.scatter_` 메소드는 텐서에 직접 값을 할당하는 in-place 연산으로, 여기서는 원-핫 인코딩을 생성하는 데 사용됩니다.
   - 첫 번째 인자 `0`은 차원(dim)을 나타내며, 여기서는 0번째 차원(즉, 텐서의 길이 방향)에 대해 작업을 수행한다는 것을 의미합니다.
   - `torch.tensor(y)`는 레이블 `y`를 텐서로 변환합니다. 이 텐서는 `.scatter_` 메소드에서 인덱스로 사용됩니다.
   - `value=1`은 지정된 인덱스의 위치에 할당될 값으로, 이 경우에는 1입니다. 즉, 레이블 `y`에 해당하는 위치에 1을 할당하여 원-핫 인코딩을 완성합니다.

##### 해설
이 코드는 레이블 `y`를 입력으로 받아, 해당 레이블에 해당하는 위치를 제외하고 모두 0인 길이가 10인 텐서를 생성하고, `y`에 해당하는 위치만 값을 1로 설정하여 원-핫 인코딩된 벡터를 반환합니다. 예를 들어, 레이블 `y`가 3이라면, 이 코드는 `[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]`과 같은 텐서를 생성합니다.

이러한 원-핫 인코딩 방식은 분류 문제에서 널리 사용되며, 각 클래스가 독립적인 출력으로 표현되어야 할 때 유용합니다. 이 방법은 모델이 각 클래스에 대한 확률을 분명하게 예측하도록 돕습니다.




### ToTensor()

ToTensor 는 PIL Image나 NumPy ndarray를 FloatTensor로 변환하고, 이미지 픽셀의 크기(intensity) 값을 [0., 1.]범위로 비례하여 조정(scale)한다.


### Lambda 변형(Transform)

Lambda 변형은 사용자 정의 람다(lambda) 함수를 적용한다. 여기에서는 정수를 one-hot 으로 인코딩된 텐서로 바꾸는 함수를 정의. 
이 함수는 먼저 (데이터셋 정답 갯수인) 크기 10짜리 0 텐서(zero tensor)를 만들고, scatter_ 를 호출하여 주어진 정답 y에 해당하는 인덱스에 value = 1을 할당

``` python
target_transform = Lambda(lambda y: torch.zeros(
	10, dtype = torch.float).scatter_(dim = 0, index = torch.tensor(y), value = 1))
```




FCAM-P1_05
### 신경망 모델 구성하기
