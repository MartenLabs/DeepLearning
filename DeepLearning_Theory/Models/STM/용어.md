

### 활성화 데이터 

모델의 활성화 데이터는 모델 내부에서 연산되는 중간 결과(즉 각 계층(layer)의 출력값)들을 저장하기 위한 메모리 공간을 의미한다. 이 데이터는 모델의 다음 계층으로 전달되며, 최종 출력을 생성하는 데 필요한 정보를 포함하고 있다. 즉 모델이 복잡한 함수를 계산하고 최종적으로 예측을 수행하는 과정에서 생성되는 동적 데이터이다. 

#### 활성화 데이터의 역할

- **중간 계산 저장**: 모델을 실행하는 동안 각 계층의 출력은 다음 계층의 입력으로 사용된다. 이 과정에서 각 계층의 출력값, 즉 활성화 데이터는 다음 계층의 연산을 위해 임시로 저장되어야 한다.
- **역전파를 위한 정보**: 신경망을 훈련시킬 때, 역전파 알고리즘이 오류 신호를 입력층 방향으로 전달하면서 가중치를 조정한다. 이 과정에서 각 계층의 활성화 데이터는 오류를 계산하고 가중치를 업데이트하는 데 필수적인 정보를 제공한다.

#### 활성화 데이터의 메모리 관리

- **메모리 할당**: 모델의 실행을 위해서는 각 계층의 활성화 데이터를 저장할 충분한 메모리 공간이 필하다. 이 메모리는 모델의 구조와 크기에 따라 미리 정의되어야 한다.
- **효율적인 접근**: 활성화 데이터는 추론 과정에서 빠르게 읽고 쓰여야 한다. 따라서, 데이터의 메모리 정렬과 접근 방식은 모델의 성능에 직접적인 영향을 미친다.




----

### 메모리 정렬

메모리 주소를 4바이트 단위로 증가. 즉, 각 주소가 4, 8, 12, 16 등으로 증가한다고 가정. `AI_ALIGNED(4)` 지시어는 데이터가 이러한 주소 중 하나에서 시작되도록 한다. 예를 들어, 어떤 변수가 메모리 주소 4에서 시작한다면, 그 변수는 4바이트 경계에 정렬된 것.

#### 정렬되지 않은 경우

```
주소:   0x01  0x02  0x03  0x04  0x05  0x06  0x07  0x08
데이터:  [A]   [A]   [A]   [B]   [B]   [B]   [B]   [C]
```

- `[A]`는 주소 0x01에서 시작하는 3바이트 데이터. 이 데이터는 4바이트 경계에 맞춰져 있지 않다.
- `[B]`는 주소 0x04에서 시작하는 4바이트 데이터. 이 데이터는 4바이트 경계에 정렬된다.
- `[C]`는 0x08 주소에 있는 단일 바이트 데이터.


#### 4바이트 경계에 정렬된 경우

```
주소:   0x04  0x08  0x0C  0x10  0x14  0x18  0x1C  0x20
데이터:  [D]   [D]   [D]   [D] | [E]   [E]   [E]   [E]
```

- `[D]`는 주소 0x04에서 시작하는 4바이트 데이터. 이 데이터는 4바이트 경계에 정확히 맞춰져 있다.
- `[E]`는 주소 0x14에서 시작하는 다른 4바이트 데이터. 이 데이터 역시 4바이트 경계에 정확히 맞춰져 있다.


#### 부족한 부분에 대한 패딩 (Padding)

```
메모리 주소: 0x04  0x05  0x06  0x07  0x08
데이터:      [A]   [A]   [A]   [ ]   ...
```
- 데이터가 정렬을 위해 요구되는 크기에 도달하지 못하는 경우, 나머지 공간은 패딩으로 채워진다. 예를 들어, 3바이트 데이터를 4바이트 경계에 맞추어 저장하려고 할 때, 1바이트의 패딩이 추가된다.       이 패딩은 해당 데이터의 일부로 처리되지 않으며 단순히 메모리를 채우는 역할만 한다. 


#### 넘치는 부분에 대한 처리

- 데이터가 특정 경계를 넘어설 경우, 즉 데이터 크기가 정렬 크기의 배수가 아닐 경우, 데이터는 여전히 시작점에서 정렬 경계에 맞춰 저장된다. 예를 들어, 5바이트 데이터를 4바이트 경계에 맞춰 저장하려고 할 때, 처음 4바이트는 첫 번째 4바이트 경계에 저장되고, 나머지 1바이트는 다음 4바이트 경계에 저장된다. 이 경우, 다음 데이터는 이 1바이트 뒤의 다음 4바이트 경계에서 시작된다. 여기서는 "넘치는" 부분에 대해 특별히 처리할 필요가 없으며, 데이터는 자연스럽게 연속적으로 메모리에 배치된다.
```
[4바이트 데이터] [3바이트 데이터 + 1바이트 패딩] [5바이트 데이터 + 3바이트 패딩] ...
```

- 4바이트 데이터는 그대로 4바이트 경계에 맞춰 저장
- 3바이트 데이터는 1바이트의 패딩이 추가되어 다음 4바이트 경계에 맞춰 저장
- 5바이트 데이터는 첫 4바이트가 첫 번째 4바이트 경계에 저장되고, 나머지 1바이트는 다음 4바이트 경계의 시작에 저장. 이후 데이터는 이 5바이트 데이터 뒤의 3바이트 패딩을 고려하여 다음 4바이트 경계에서 시작.


#### 왜 메모리 정렬이 중요한가?

메모리 정렬은 프로세서가 메모리에 접근하는 효율성을 개선한다. 많은 프로세서는 특정 바이트 경계에 정렬된 데이터를 더 빠르게 읽고 쓸 수 있으며, 때로는 정렬되지 않은 데이터에 접근하려고 할 때 추가적인 성능 비용이 발생할 수 있다. 따라서, 데이터를 적절히 정렬하는 것은 시스템의 전반적인 성능을 향상시키는 중요한 방법 중 하나이다.

4바이트 경계에 정렬한다는 것은 메모리 주소가 4의 배수인 위치에서 데이터가 시작되도록 하는 것을 의미한다. 즉, 데이터의 시작 주소를 4, 8, 12, 16 등과 같이 4의 배수로 설정하는 것이다. 이런 방식으로 정렬하면, 데이터의 시작 주소는 항상 4로 나누어 떨어지게 된다.

이러한 정렬은 컴퓨터의 하드웨어와 메모리 아키텍처가 데이터를 더 효율적으로 처리할 수 있게 해주어, 메모리 액세스 시간을 단축시키고 전반적인 성능을 개선할 수 있다. 예를 들어, 많은 CPU 아키텍처에서는 4바이트(또는 해당 CPU에 최적화된 다른 바이트 크기) 경계에 정렬된 데이터를 한 번에 읽어들일 수 있어, 데이터 처리 속도가 빨라진다.

이는 특히 큰 데이터 구조체나 배열을 메모리에 할당할 때 중요한데, 이렇게 하면 CPU가 각 데이터 요소를 더 빨리 액세스하고, 결과적으로 프로그램의 전체 실행 시간을 단축할 수 있다.


---

### MACC (Multiply-Accumulate 연산)

모델이 수행해야 하는 총 MAC 연산의 수. 이는 모델의 계산 복잡도를 나타내는 지표 중 하나

Multiply-Accumulate (MAC) 연산은 딥 러닝과 같은 컴퓨터 연산에서 매우 일반적으로 사용되는 기본 연산이다. 하나의 MAC 연산은 곱셈 한 번과 덧셈 한 번을 수행한다. 예를 들어, 신경망에서 한 뉴런의 출력을 계산할 때, 입력 피처(feature)들과 해당 가중치(weights)들의 곱의 합을 구하는 것은 MAC 연산을 여러 번 수행하는 것과 같다.

---

### C_MACC

`c_macc`는 해당 계층까지의 누적 Multiply-Accumulate 연산의 비율을 나타낸다. 이는 모델의 전체 연산량에서 각 계층이 차지하는 비율을 퍼센테이지(%)로 표현한 것이다.

`c_macc` 값은 해당 계층까지 모델이 수행해야 하는 전체 MAC 연산의 양을 퍼센트로 나타낸 것으로, 모델의 성능 및 복잡성을 평가하는 데 사용될 수 있다. 높은 `c_macc` 값은 그 계층이 모델 내에서 상대적으로 더 많은 연산을 수행함을 의미한다. 이는 해당 계층이 모델의 계산 비용에 큰 영향을 미친다는 것을 나타내며, 최적화의 대상이 될 수 있다.


